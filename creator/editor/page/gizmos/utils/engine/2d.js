"use strict";let e=require("./engine-interface");const t=Editor.require("packages://scene/panel/tools/camera"),r=require("../../3d/elements/utils/controller-shape-collider");let n=require("../external").GeometryUtils.aabb,o=cc.gfx;function s(e,t){let r=e.getComponent(cc.MeshRenderer);if(r){let e=r.sharedMaterials[0];e&&e.setProperty("diffuseColor",t)}}let i={ORTHO:0,PERSPECTIVE:1};module.exports=new class extends e{constructor(){super(),this.gfx=o,this.ProjectionType=i}create3DNode(e){let t=new cc.Node(e);return t.is3DNode=!0,t._objFlags|=cc.Object.Flags.DontSave|cc.Object.Flags.HideInHierarchy,t}createMesh(e){let t=new cc.Mesh,r=new o.VertexFormat([{name:o.ATTR_POSITION,type:o.ATTR_TYPE_FLOAT32,num:3},{name:o.ATTR_NORMAL,type:o.ATTR_TYPE_FLOAT32,num:3}]);return t.init(r,e.positions.length,!0),t.setVertices(o.ATTR_POSITION,e.positions),e.normals&&t.setVertices(o.ATTR_NORMAL,e.normals),t.setIndices(e.indices),e.minPos&&(t._minPos=e.minPos),e.maxPos&&(t._maxPos=e.maxPos),void 0!==e.primitiveType&&t.setPrimitiveType(e.primitiveType),t}addMeshToNode(e,t,r={}){let n=e.addComponent(cc.MeshRenderer);n.mesh=t;let s=new cc.Material;if(r.unlit?(s.effectName="__builtin-editor-gizmo-unlit",s.effect&&s.effect.getTechnique("transparent").passes[0].setDepth(!1)):t.subMeshes[0]._primitiveType<o.PT_TRIANGLES?r.noDepthTestForLines?(s.effectName="__builtin-editor-gizmo-unlit",s.effect&&s.effect.getTechnique("transparent").passes[0].setDepth(!1)):s.effectName="__builtin-editor-gizmo-line":s.effectName="__builtin-editor-gizmo",s.effect){let e=s.effect.getTechnique("transparent").passes[0];r.cullMode&&e.setCullMode(r.cullMode)}n.setMaterial(0,s)}setMeshColor(e,t){e.color=t;let r=t.clone();r.a=e.opacity,s(e,r)}getMeshColor(e){return e.color}setNodeOpacity(e,t){e.opacity=t;let r=e.color;r.a=t,s(e,r)}getNodeOpacity(e){return e.opacity}getRaycastResults(e,n,s){let i=t._camera.getRay(cc.v3(n,s,1)),c=cc.geomUtils.intersect.raycast(e,i,(e,t,n)=>{let s=t.getComponent(r);if(s&&s.isDetectMesh){let r=t.getComponent(cc.MeshRenderer),n=r.mesh._subMeshes;if(r&&r.mesh&&n&&n[0]._primitiveType===o.PT_TRIANGLES)return cc.geomUtils.intersect.rayMesh(e,r.mesh)}return n},function(e){return null!=e.getComponent(cc.MeshRenderer)&&!1!==e.active});return c.ray=i,c}getModel(e){return e.getComponent(cc.MeshRenderer)}updateVBAttr(e,t,r){e.setVertices(t,r)}getBoudingBox(e){let t=null;if(e instanceof cc.MeshRenderer){let r=e.mesh;r&&(t=n.fromPoints(n.create(),r._minPos,r._maxPos))}else console.error("target is not a cc.MeshRenderer");return t}getRootBoneNode(e){let t=null;if(e instanceof cc.SkinnedMeshRenderer){let r=e._joints;r&&r.length>0&&(t=r[0])}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getRootBindPose(e){let t=null;if(e instanceof cc.SkinnedMeshRenderer){let r=e.skeleton;r&&(t=r.bindposes[0])}else console.error("target is not a cc.SkinnedMeshRenderer");return t}getCameraData(e){let t=null;return e instanceof cc.Camera?(t={},e.ortho?t.projection=i.ORTHO:t.projection=i.PERSPECTIVE,t.orthoHeight=e.orthoSize,t.fov=e.fov,t.aspect=cc.winSize.width/cc.winSize.height,t.near=e.nearClip,t.far=e.farClip):console.error("target is not a cc.Camera"),t}setCameraData(e,t){e instanceof cc.Camera?(t.fov&&(e.fov=t.fov),t.far&&(e.farClip=t.far),t.orthoHeight&&(e.orthoSize=t.orthoHeight)):console.error("target is not a cc.Camera")}getLightData(e){let t=null;return e instanceof cc.Light?((t={}).type=e.type,t.range=e.range,t.spotAngle=e.spotAngle):console.error("target is not a cc.Light"),t}setLightData(e,t){e instanceof cc.Light?(t.range&&(e.range=t.range),t.spotAngle&&(e.spotAngle=t.spotAngle)):console.error("target is not a cc.Light")}};